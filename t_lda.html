<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Análise de Discriminantes Lineares – PSI5892</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e0b2e4e5c4db31b3b64fdef51415d7d2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">PSI5892</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Procurar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Alternar de navegação" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teoria" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teoria</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teoria">    
        <li>
    <a class="dropdown-item" href="./t_introducao.html">
 <span class="dropdown-text">Introdução</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_regressao_linear.html">
 <span class="dropdown-text">Regressão linear</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_lms.html">
 <span class="dropdown-text">O algoritmo LMS</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_neuronio.html">
 <span class="dropdown-text">O modelo do neurônio</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_mlp.html">
 <span class="dropdown-text">A rede perceptron multicamada</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_hiperparametros.html">
 <span class="dropdown-text">Evitando mínimos locais e <em>overfitting</em></span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_autodiff.html">
 <span class="dropdown-text">Introdução à diferenciação automática</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pytorch_topicos.html">
 <span class="dropdown-text">Tópicos sobre o <em>framework</em> PyTorch</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pytorch_exemplo_mlp.html">
 <span class="dropdown-text">Implementação da rede MLP com PyTorch</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_medidas.html">
 <span class="dropdown-text">Medidas de desempenho</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pca.html">
 <span class="dropdown-text">Análise de Componentes Principais</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_lda.html">
 <span class="dropdown-text">Análise de Discriminantes Lineares</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-material-de-apoio" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Material de apoio</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-material-de-apoio">    
        <li>
    <a class="dropdown-item" href="./ap_python_topicos.html">
 <span class="dropdown-text">Tópicos de programação com Python</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Análise de Discriminantes Lineares</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="justify">
<div hidden="">
<p><span class="math display">\[
\newcommand{\Her}{\scriptscriptstyle H}
\newcommand{\T}{\rm T}
%\newcommand{\R}{\scriptscriptstyle R}
\newcommand{\I}{\scriptscriptstyle I}
\newcommand{\mT}{\scriptscriptstyle -T}
\newcommand{\vir}{,\hspace{-0.15ex}}
\newcommand{\M}{\scriptscriptstyle M}
\newcommand{\RNN}{\rm \scriptscriptstyle RNN}
\newcommand{\E}{{\rm E}}
\newcommand{\uM}{{\mathbf u}}
\newcommand{\aM}{{\mathbf a}}
\newcommand{\bM}{{\mathbf b}}
\newcommand{\cM}{{\mathbf c}}
\newcommand{\sM}{{\mathbf s}}
\newcommand{\SM}{{\mathbf S}}
\newcommand{\vM}{{\mathbf v}}
\newcommand{\UM}{{\mathbf U}}
\newcommand{\VM}{{\mathbf V}}
\newcommand{\RM}{{\mathbf R}}
\newcommand{\DM}{{\mathbf D}}
\newcommand{\PM}{{\mathbf P}}
\newcommand{\HM}{{\mathbf H}}
\newcommand{\LM}{{\mathbf L}}
\newcommand{\AM}{{\mathbf A}}
\newcommand{\FM}{{\mathbf F}}
\newcommand{\BM}{{\mathbf B}}
\newcommand{\QM}{{\mathbf Q}}
\newcommand{\SigmaM}{{\boldsymbol{\Sigma}}}
\newcommand{\IM}{{\mathbf I}}
\newcommand{\JM}{{\mathbf J}}
\newcommand{\yM}{{\mathbf y}}
\newcommand{\yhM}{\hat{\mathbf y}}
\newcommand{\xhM}{\hat{\mathbf x}}
\newcommand{\zM}{{\mathbf z}}
\newcommand{\xM}{{\mathbf x}}
\newcommand{\eM}{{\mathbf e}}
\newcommand{\zeroM}{{\mathbf 0}}
\newcommand{\rM}{{\mathbf r}}
\newcommand{\w}{{\mathbf w}}
\newcommand{\wtil}{\widetilde{\mathbf w}}
\newcommand{\Dw}{\boldsymbol{\Delta}{\mathbf w}}
\newcommand{\Dewp}{\boldsymbol{\Delta}{\mathbf{\dot{w}}}}
\newcommand{\wo}{{\mathbf w}_{\rm o}}
\newcommand{\q}{{\mathbf q}}
\newcommand{\Nuquad}{\|{\mathbf u(n)}\|^2}
\newcommand{\traco}{{\rm Tr}}
\newcommand{\snum}{\mathbf{s}_{n\!-\!1}}
\]</span></p>
</div>
<p>Embora a PCA encontre componentes úteis para representar o conjunto de dados, não há razão para supor que esses componentes são úteis para classificar dados de diferentes classes. Se reunirmos todas as amostras, as direções descartadas pela PCA podem ser exatamente as direções necessárias para distinguir entre as classes. Por exemplo, se tivéssemos dados para as letras maiúsculas impressas <em>O</em> e <em>Q</em>, a PCA pode descobrir as características grosseiras que caracterizam <em>O</em>’s e <em>Q</em>’s, mas pode ignorar a cauda que distingue um <em>O</em> de um <em>Q</em>. Enquanto a PCA busca direções que são eficientes para a representação, a análise de discriminante linear busca direções que são eficientes para discriminação.</p>
<p>A seguir, vamos detalhar essa técnica, começando com o caso particular de duas classes.</p>
<section id="discriminante-linear-de-fisher" class="level2">
<h2 class="anchored" data-anchor-id="discriminante-linear-de-fisher">Discriminante Linear de Fisher</h2>
<p>Vamos começar considerando o problema de projetar um vetor de dados com <span class="math inline">\(D\)</span> elementos em uma reta. Mesmo que as amostras formassem agrupamentos compactos e bem separados em no espaço de dimensão <span class="math inline">\(D\)</span>, a projeção em uma reta arbitrária geralmente produzirá uma mistura confusa de amostras de todas as classes, o que leva a um desempenho de classificação ruim. No entanto, girando-se a reta, pode-se encontrar uma direção para a qual as amostras projetadas estão bem separadas. Este é exatamente o objetivo da <strong>Análise de Discriminante Linear</strong>.</p>
<p>Considere um problema de classificação com <span class="math inline">\(K=2\)</span> classes e um conjunto de dados formado por <span class="math inline">\(N\)</span> vetores coluna <span class="math inline">\(\mathbf{x}_n\)</span> de dimensão <span class="math inline">\(D\times 1\)</span> e elementos reais, ou seja, <span class="math inline">\(\{\mathbf{x}_n\in \mathbb{R}^{D}\}\)</span>, <span class="math inline">\(n=1, 2, \ldots, N\)</span>. Considere ainda que desses <span class="math inline">\(N\)</span> vetores, há <span class="math inline">\(N_1\)</span> vetores no subconjunto <span class="math inline">\({\cal D}_1\)</span> rotulados como pertencentes à classe <span class="math inline">\(C_1\)</span> e <span class="math inline">\(N_2\)</span> vetores no subconjunto <span class="math inline">\({\cal D}_2\)</span> rotulados como pertencentes à classe <span class="math inline">\(C_2\)</span>. Uma combinação linear dos componentes do vetor <span class="math inline">\(\mathbf{x}_n\)</span> leva ao produto escalar</p>
<p><span class="math display">\[
y_n=\mathbf{w}^{\rm T}\mathbf{x}_n.
\]</span></p>
<p>Supondo que <span class="math inline">\(\|\mathbf{w}\|=1\)</span>, cada <span class="math inline">\(y_n\)</span> é a projeção do correspondente <span class="math inline">\(\mathbf{x}_n\)</span> na direção de <span class="math inline">\(\mathbf{w}\)</span>. A norma de <span class="math inline">\(\mathbf{w}\)</span> não tem importância porque ela meramente escalona <span class="math inline">\(y_n\)</span>, mas a sua a direção é importante. Cabe observar que o conjunto das <span class="math inline">\(N\)</span> amostras <span class="math inline">\(y_1, y_2, \cdots, y_N\)</span> pode ser dividido em dois subconjuntos <span class="math inline">\({\cal Y}_1\)</span> e <span class="math inline">\({\cal Y}_2\)</span>, correspondentes às classes <span class="math inline">\(C_1\)</span> e <span class="math inline">\(C_2\)</span>, respectivamente.</p>
<p>Se as amostras rotuladas como <span class="math inline">\(C_1\)</span> estão em um agrupamento e as rotuladas como <span class="math inline">\(C_2\)</span> em outro, deseja-se que as projeções na direção de <span class="math inline">\(\mathbf{w}\)</span> sejam bem separadas. A Figura~<span class="math inline">\(\ref{fig:Fisher}\)</span> ilustra o efeito de escolher direções diferentes para <span class="math inline">\(\mathbf{w}\)</span> em um exemplo bidimensional. Se as distribuições originais forem multimodais e altamente sobrepostas, mesmo o “melhor” <span class="math inline">\(\mathbf{w}\)</span> pode ser incapaz de fornecer uma separação adequada e, portanto, esse método será de pouca utilidade.</p>
<div id="fig-fisher" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fisher-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="././images/Fisher.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fisher-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;1: Projeção do mesmo conjunto de amostras em duas direções diferentes definidas pelo vetor <span class="math inline">\(\mathbf{w}\)</span>. No gráfico da direita, é possível observar que há uma separação maior entre os pontos vermelhos e os pontos pretos. Fonte: <span class="citation" data-cites="duda_pattern_2000">(<a href="#ref-duda_pattern_2000" role="doc-biblioref">Duda, Hart, e Stork 2000</a>)</span>
</figcaption>
</figure>
</div>
<p>Vamos agora encontrar a melhor direção <span class="math inline">\(\mathbf{w}\)</span> supondo que seja possível obter uma boa classificação. Uma medida da separação entre as pontos projetados é a diferença entre as médias dos dois subconjuntos. Seja <span class="math display">\[
\mathbf{m}_i=\frac{1}{N_i}\sum_{\mathbf{x}\in {\cal D}_i}\mathbf{x}
\]</span></p>
<p>o vetor <span class="math inline">\(D\times 1\)</span> que representa a média dos dados da classe <span class="math inline">\(C_i\)</span>. Então, a média dos dados projetados da classe <span class="math inline">\(C_i\)</span> é dada por <span class="math display">\[
\widetilde{m}_i=\frac{1}{N_i}\sum_{y\in {\cal Y}_i}y=\frac{1}{N_i}\sum_{\mathbf{x}\in {\cal D}_i}\mathbf{w}^{\rm T}\mathbf{x}=\mathbf{w}^{\rm T}\frac{1}{N_i}\sum_{\mathbf{x}\in {\cal D}_i}\mathbf{x}=\mathbf{w}^{\rm T}\mathbf{m}_i,
\]</span></p>
<p>que corresponde à projeção do vetor <span class="math inline">\(\mathbf{m}_i\)</span> na direção de <span class="math inline">\(\mathbf{w}\)</span>.</p>
<p>A distância entre as médias projetadas é <span class="math display">\[
|\widetilde{m}_1-\widetilde{m}_2|=|\mathbf{w}^{\rm T}(\mathbf{m}_1-\mathbf{m}_2)|.
\]</span></p>
<p>Essa diferença depende da norma de <span class="math inline">\(\mathbf{w}\)</span> e pode ser tão grande quanto se queira. Para se obter uma boa separação dos dados projetados, desejamos que a diferença entre as médias seja grande e que os dados projetados apresentem uma pequena variação em torno da média de cada classe. Definindo</p>
<p><span class="math display">\[
\widetilde{s}_i^2=\sum_{y\in {\cal Y}_i}(y-\widetilde{m}_i)^2,
\]</span></p>
<p>então <span class="math display">\[
\frac{\widetilde{s}_1^2+\widetilde{s}_2^2}{N}
\]</span></p>
<p>é uma estimativa da variância dos dados agrupados e a soma <span class="math inline">\(\widetilde{s}_1^2+\widetilde{s}_2^2\)</span> é chamada de dispersão total das amostras projetadas dentro da classe (<em>within-class scatter</em>).</p>
<p>O <strong>Discriminante Linear de Fisher</strong> busca o vetor <span class="math inline">\(\mathbf{w}\)</span> (independente de sua norma) que maximiza o seguinte critério</p>
<p><span class="math display">\[
J(\mathbf{w})=\frac{(\widetilde{m}_1-\widetilde{m}_2)^2}{\widetilde{s}_1^2+\widetilde{s}_2^2}.
\]</span></p>
<p>Para obter <span class="math inline">\(J(\cdot)\)</span> como uma função explicita de <span class="math inline">\(\mathbf{w}\)</span>, vamos definir as matrizes de dispersão <span class="math inline">\(\mathbf{S}_i\)</span> e <span class="math inline">\(\mathbf{S}_W\)</span>, ou seja, <span class="math display">\[
\mathbf{S}_i=\sum_{x\in{\cal D}_i}(\mathbf{x}-\mathbf{m}_i)(\mathbf{x}-\mathbf{m}_i)^{\rm T}
\]</span></p>
<p>e <span class="math display">\[
\mathbf{S}_{W}=\mathbf{S}_1+\mathbf{S}_2.
\]</span></p>
<p>Então, podemos escrever</p>
<p><span class="math display">\[
\widetilde{s}_i^2=\sum_{x\in{\cal D}_i}(\mathbf{w}^{\rm T}\mathbf{x}-\mathbf{w}^{\rm T}\mathbf{m}_i)^2=\sum_{x\in{\cal D}_i}\mathbf{w}^{\rm T}(\mathbf{x}-\mathbf{m}_i)(\mathbf{x}-\mathbf{m}_i)^{\rm T}\mathbf{w}=\mathbf{w}^{\rm T}\mathbf{S}_i\mathbf{w}.
\]</span></p>
<p>Consequentemente, a dispersão total pode ser escrita como <span class="math display">\[
\widetilde{s}_1^2+\widetilde{s}_2^2=\mathbf{w}^{\rm T}\mathbf{S}_W\mathbf{w}.
\]</span></p>
<p>Similarmente, <span class="math display">\[
(\widetilde{m}_1-\widetilde{m}_2)^2=(\mathbf{w}^{\rm T}\mathbf{m}_1-\mathbf{w}^{\rm T}\mathbf{m}_2)^2=
\mathbf{w}^{\rm T}(\mathbf{m}_1-\mathbf{m}_2)(\mathbf{m}_1-\mathbf{m}_2)^{\T}\mathbf{w}=\mathbf{w}^{\rm T}\mathbf{S}_B\mathbf{w}
\]</span></p>
<p>em que</p>
<p><span class="math display">\[
\mathbf{S}_B\triangleq (\mathbf{m}_1-\mathbf{m}_2)(\mathbf{m}_1-\mathbf{m}_2)^{\T}.
\]</span></p>
<p>A matriz <span class="math inline">\(\mathbf{S}_W\)</span> é chamada de matriz de dispersão dentro da classe. Ela é proporcional à matriz de covariância dos dados de dimensão <span class="math inline">\(D\)</span> agrupados. Ela é simétrica e positiva semidefinida, e geralmente é não singular se <span class="math inline">\(N &gt; D\)</span>. Analogamente, <span class="math inline">\(\mathbf{S}_B\)</span> é chamada de matriz de dispersão entre classes. No entanto, apesar de ser simétrica, por ser o produto externo de dois vetores, seu posto é no máximo um. Em particular, para qualquer <span class="math inline">\(\mathbf{w}\)</span>, <span class="math inline">\(\mathbf{S}_B\mathbf{w}\)</span> está na direção de <span class="math inline">\((\mathbf{m}_1-\mathbf{m}_2)\)</span> e <span class="math inline">\(\mathbf{S}_B\)</span> é singular.</p>
<p>Em termos dessas matrizes, <span class="math inline">\(J(\mathbf{w})\)</span> pode ser escrito como</p>
<p><span class="math display">\[
J(\mathbf{w})=\frac{\mathbf{w}^{\rm T}\mathbf{S}_B\mathbf{w}}{\mathbf{w}^{\rm T}\mathbf{S}_W\mathbf{w}},
\]</span></p>
<p>que é conhecida na física matemática como coeficiente de Rayleigh generalizado. O vetor <span class="math inline">\(\mathbf{w}\)</span> que maximiza <span class="math inline">\(J(\mathbf{w})\)</span> deve satisfazer o critério <span class="math display">\[
\max_{\mathbf{w}\neq \mathbf{0}}\frac{\mathbf{w}^{\rm T}\mathbf{S}_B\mathbf{w}}{\mathbf{w}^{\rm T}\mathbf{S}_W\mathbf{w}},
\]</span></p>
<p>que é equivalente ao seguinte critério com restrição</p>
<p><span class="math display">\[
\max_{\mathbf{w}\in \mathbb{R}^{D}} \mathbf{w}^{\rm T}\mathbf{S}_B\mathbf{w},\;\;\text{sujeito a}\;\;\mathbf{w}^{\rm T}\mathbf{S}_W\mathbf{w}=1.
\]</span></p>
<p>Para resolver esse critério, podemos usar a técnica de multiplicadores de Lagrange. Assim, obtemos a seguinte função custo</p>
<p><span class="math display">\[
J_{\lambda}(\mathbf{w})=\mathbf{w}^{\rm T}\mathbf{S}_B\mathbf{w}+\lambda(1-\mathbf{w}^{\rm T}\mathbf{S}_W\mathbf{w}).
\]</span></p>
<p>Calculando a derivada em relação <span class="math inline">\(\mathbf{w}\)</span>, obtém-se</p>
<p><span class="math display">\[
\frac{d J_{\lambda}(\mathbf{w})}{d \mathbf{w}}=\mathbf{S}_B\mathbf{w}-\lambda\mathbf{S}_W\mathbf{w}.
\]</span></p>
<p>Igualando essa derivada a zero e se <span class="math inline">\(\mathbf{S}_{W}\)</span> for não singular, podemos escrever</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\mathbf{S}_{W}^{-1}\mathbf{S}_{B}\mathbf{w}=\lambda \mathbf{w}
$}
\end{equation*}\]</span></p>
<p>Assim, <span class="math inline">\(\mathbf{w}\)</span> é o autovetor relacionado ao único autovalor não nulo, <span class="math inline">\(\lambda\)</span>, da matriz <span class="math inline">\(\mathbf{S}_{W}^{-1}\mathbf{S}_{B}\)</span>. Cabe observar que a matriz <span class="math inline">\(\mathbf{S}_{W}^{-1}\mathbf{S}_{B}\)</span> continua com posto igual a um e por isso tem um único autovalor não nulo. No caso particular, como <span class="math inline">\(\mathbf{S}_B\mathbf{w}\)</span> está na direção de <span class="math inline">\((\mathbf{m}_1-\mathbf{m}_2)\)</span>, pode-se calcular <span class="math inline">\(\mathbf{w}\)</span> como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\mathbf{w}=\mathbf{S}_{W}^{-1}(\mathbf{m}_1-\mathbf{m}_2).
$}
\end{equation*}\]</span></p>
<p>Assim, a classificação foi convertida de um problema <span class="math inline">\(D\)</span>-dimensional para um problema de classificação em uma dimensão, ou seja, <span class="math inline">\(K-1\)</span> (quantidade de classes menos um).</p>
<p>Em suma, o Discriminante Linear de Fisher projeta o vetor <span class="math inline">\(\mathbf{x}\)</span> de dimensão <span class="math inline">\(D\)</span> em uma dimensão, ou seja, <span class="math inline">\(y=\mathbf{w}^{\rm T}\mathbf{x}\)</span>. Comparando <span class="math inline">\(y\)</span> com um limiar, este método pode classificar <span class="math inline">\(\mathbf{x}\)</span> como pertencente à classe <span class="math inline">\(C_1\)</span> ou à classe <span class="math inline">\(C_2\)</span>. Para esse propósito, <span class="math inline">\(\mathbf{w}\)</span> deve ser calculado tal que as médias dos dados projetados das duas classes fiquem o mais distante possível uma da outra. Além disso, a variância dos dados projetos de cada classe deve ser a menor possível, o que possibilita uma grande concentração dos dados de cada classe em torno de sua média e a possibilidade de uma classificação correta.</p>
</section>
<section id="extensão-para-mais-de-duas-classes" class="level2">
<h2 class="anchored" data-anchor-id="extensão-para-mais-de-duas-classes">Extensão para mais de duas classes</h2>
<p>A <strong>Análise de Discriminante Linear</strong> (LDA - <em>Linear Discriminant Analysis</em>) é a generalização do Discriminante Linear de Fisher para mais de duas classes (<span class="math inline">\(K&gt;2\)</span>). Nessa generalização, o vetor <span class="math inline">\(\mathbf{x}_n\)</span> de dimensão <span class="math inline">\(D&gt;K\)</span> é projetado no espaço de dimensão <span class="math inline">\((K-1)\)</span> por meio da transformação</p>
<p><span class="math display">\[
\mathbf{y}_n=\mathbf{W}^{\rm T}\mathbf{x}_n
\]</span></p>
<p>em que</p>
<p><span class="math display">\[
\mathbf{W}=[\mathbf{w}_1\;\mathbf{w}_2\;\cdots\;\mathbf{w}_{K-1}]
\]</span></p>
<p>é uma matriz com dimensões <span class="math inline">\(D \times (K-1)\)</span>, formada por vetores coluna <span class="math inline">\(\mathbf{w}_k\)</span>, <span class="math inline">\(k=1,2,\cdots, K-1\)</span>. Assim, o vetor <span class="math inline">\(\mathbf{y}_n\)</span> passa a ter a dimensão do número de classes do problema menos um.</p>
<p>Como no Discriminante Linear de Fisher, a LDA busca maximizar a separação entre as classes e ao mesmo tempo reduzir a sobreposição entre elas. Para isso, deve-se estender as definições das matrizes de dispersão entre classes <span class="math inline">\(\mathbf{S}_B\)</span> e de dispersão dentro das classes <span class="math inline">\(\mathbf{S}_W\)</span>, vistas anteriormente. Assim, obtém-se para o caso de <span class="math inline">\(K\)</span> classes</p>
<p><span class="math display">\[\begin{align}
\mathbf{S}_B&amp;=\sum_{k=1}^{K}N_k(\mathbf{m}_k-\mathbf{m})(\mathbf{m}_k-\mathbf{m})^{\rm T}\nonumber\\
\mathbf{S}_W&amp;=\sum_{k=1}^{K}\sum_{\mathbf{x}\in{\cal D}_i}(\mathbf{x}-\mathbf{m}_i)(\mathbf{x}-\mathbf{m}_i)^{\rm T}\nonumber
\end{align}\]</span></p>
<p>em que</p>
<p><span class="math display">\[
\mathbf{m}=\frac{1}{N}\sum_{n=1}^{N}{\mathbf{x}_n}
\]</span></p>
<p>representa a média global do conjunto de dados. Cabe observar que o termo <span class="math inline">\((\mathbf{m}_k-\mathbf{m})\)</span> que aparece em <span class="math inline">\(\mathbf{S}_B\)</span> é o desvio da média de cada classe da média global. Esses desvios formam um conjunto de <span class="math inline">\(K\)</span> vetores no espaço de características. Entretanto, esses vetores não são independentes. A média global é uma média ponderada das médias das classes, ou seja,</p>
<p><span class="math display">\[
\mathbf{m}=\frac{1}{N}\sum_{k=1}^{K}N_k\mathbf{m}_k.
\]</span></p>
<p>Essa relação introduz uma dependência entre os vetores das <span class="math inline">\(K\)</span> classes, o que faz com que a matriz <span class="math inline">\(\mathbf{S}_B\)</span> tenha posto no máximo igual a <span class="math inline">\(K-1\)</span>. Consequentemente, a matriz <span class="math inline">\(\mathbf{S}_W^{-1}\mathbf{S}_B\)</span> também tem posto no máximo igual a <span class="math inline">\(K-1\)</span>.</p>
<p>A função custo neste caso é dada por</p>
<p><span class="math display">\[
J(\mathbf{W})=  \text{Tr}\{(\mathbf{W}^{\rm T} \mathbf{S}_W\mathbf{W})^{-1}(\mathbf{W}^{\rm T} \mathbf{S}_B\mathbf{W})\},
\]</span></p>
<p>em que <span class="math inline">\(\text{Tr}\{\cdot\}\)</span> denota o traço de uma matriz. Essa função se reduz à vista anteriormente para <span class="math inline">\(K=2\)</span>. A matriz <span class="math inline">\(\mathbf{W}\)</span> que maximiza <span class="math inline">\(J(\mathbf{W})\)</span> é formada pelos autovetores <span class="math inline">\(\mathbf{w}_k\)</span>, <span class="math inline">\(k=1, 2, \cdots, K-1\)</span> relacionados aos autovalores não nulos de <span class="math inline">\(\mathbf{S}_W^{-1}\mathbf{S}_B\)</span>. Assim, o vetor <span class="math inline">\(\mathbf{x}_n\)</span> pode ser mapeado em um subespaço de dimensão <span class="math inline">\((K-1)\)</span> gerado pelos <span class="math inline">\(K-1\)</span> autovetores correspondentes aos autovalores não nulos. Consequentemente, a otimização de <span class="math inline">\(J(\mathbf{W})\)</span> produz <span class="math inline">\(K-1\)</span> características sem perda da classificabilidade. Essas características podem ser consideradas como entrada de um classificador como uma rede neural, o que em geral diminui a dimensionalidade do problema.</p>
</section>
</div>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Referências</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-duda_pattern_2000" class="csl-entry" role="listitem">
Duda, Richard O., Peter E. Hart, e David G. Stork. 2000. <em>Pattern <span>Classification</span></em>. 2nd edition. New York: Wiley-Interscience.
</div>
</div></section></div></main> <!-- /main -->
<script>
var custom_title = document.querySelectorAll('.custom .theorem-title');

for (let i = 0; i < custom_title.length; i++ ) {
   var mod_name = custom_title[i].innerHTML;
   custom_title[i].innerHTML = mod_name.replace("Exemplo", "Algoritmo");
};
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiada");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiada");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>