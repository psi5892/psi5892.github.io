<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Medidas de desempenho – PSI5892</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e0b2e4e5c4db31b3b64fdef51415d7d2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">PSI5892</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Procurar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Alternar de navegação" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teoria" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teoria</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teoria">    
        <li>
    <a class="dropdown-item" href="./t_introducao.html">
 <span class="dropdown-text">Introdução</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_regressao_linear.html">
 <span class="dropdown-text">Regressão linear</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_lms.html">
 <span class="dropdown-text">O algoritmo LMS</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_neuronio.html">
 <span class="dropdown-text">O modelo do neurônio</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_mlp.html">
 <span class="dropdown-text">A rede perceptron multicamada</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_hiperparametros.html">
 <span class="dropdown-text">Evitando mínimos locais e <em>overfitting</em></span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_autodiff.html">
 <span class="dropdown-text">Introdução à diferenciação automática</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pytorch_topicos.html">
 <span class="dropdown-text">Tópicos sobre o <em>framework</em> PyTorch</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pytorch_exemplo_mlp.html">
 <span class="dropdown-text">Implementação da rede MLP com PyTorch</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_medidas.html">
 <span class="dropdown-text">Medidas de desempenho</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_pca.html">
 <span class="dropdown-text">Análise de Componentes Principais</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./t_lda.html">
 <span class="dropdown-text">Análise de Discriminantes Lineares</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-material-de-apoio" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Material de apoio</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-material-de-apoio">    
        <li>
    <a class="dropdown-item" href="./ap_python_topicos.html">
 <span class="dropdown-text">Tópicos de programação com Python</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Medidas de desempenho</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="justify">
<p>Avaliar o modelo é essencial em aprendizado de máquina. Seu modelo pode fornecer resultados satisfatórios quando avaliado por uma determinada métrica, mas ruins quando avaliado por outra. Em problemas de classificação, a precisão geralmente é usada para medir o desempenho do modelo, porém essa métrica não é suficiente. A seguir, vamos abordar diferentes tipos de métricas de avaliação. As métricas estão divididas de acordo com o tipo de problema.</p>
<section id="problemas-de-classificação" class="level2">
<h2 class="anchored" data-anchor-id="problemas-de-classificação">Problemas de classificação</h2>
<p>Vamos voltar ao problema das meias-luas, em que se deseja classificar um determinado ponto como pertencente à Região A ou à Região B. Assim, deve-se responder à pergunta: <strong>Dado um determinado ponto, ele pertence à Região A?</strong> Há duas possíveis respostas: <font color="blue">Sim</font> ou <font color="red">Não</font>, sendo que quando ocorre a resposta negativa, subentende-se que o ponto pertence à Região B. Neste caso, os elementos relevantes são os da Região A. Por exemplo, quando se deseja detectar câncer de mama utilizando imagens de mamografia, os exames classificados como “presença de câncer”, ou seja, como positivos, são os elementos relevantes do problema. Os tipos de erros de classificação estão mostrados na <a href="#tbl-tiposerros" class="quarto-xref">Tabela&nbsp;1</a>.</p>
<div id="tbl-tiposerros" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tiposerros-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;1: Tipos de erro de classificação.
</figcaption>
<div aria-describedby="tbl-tiposerros-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 29%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Rótulo verdadeiro</th>
<th style="text-align: center;">Rótulo predito</th>
<th style="text-align: left;">Tipo de Erro</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><font color="blue">Sim</font></td>
<td style="text-align: center;"><font color="blue">Sim</font></td>
<td style="text-align: left;">Verdadeiro Positivo (VP)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><font color="red">Não</font></td>
<td style="text-align: center;"><font color="red">Não</font></td>
<td style="text-align: left;">Verdadeiro Negativo (VN)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><font color="red">Não</font></td>
<td style="text-align: center;"><font color="blue">Sim</font></td>
<td style="text-align: left;">Falso Positivo (FP)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><font color="blue">Sim</font></td>
<td style="text-align: center;"><font color="red">Não</font></td>
<td style="text-align: left;">Falso Negativo (FN)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Na <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>, é mostrado um diagrama dos erros de classificação. Os elementos classificados como positivos (elementos recuperados) são os que se encontram no interior da circunferência e são divididos em dois grupos: verdadeiros positivos e falsos positivos. Os elementos classificados como negativos estão fora da circunferência e também são divididos em dois grupos: falsos negativos e verdadeiros negativos.</p>
<div id="fig-diagrama" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-diagrama-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/diagrama.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-diagrama-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;1: Diagrama dos erros de classificação. Fonte: Adaptado de <a href="https://en.wikipedia.org/wiki/Precision_and_recall">https://en.wikipedia.org/wiki/Precision_and_recall</a>
</figcaption>
</figure>
</div>
</section>
<section id="matriz-de-confusão" class="level2">
<h2 class="anchored" data-anchor-id="matriz-de-confusão">Matriz de confusão</h2>
<p>A matriz de confusão é uma tabela que contém o resumo dos resultados de um problema de classificação. Os números de predições corretas e incorretas são resumidos com valores de contagem e divididos por cada classe. Ela mostra as maneiras pelas quais seu modelo de classificação fica confuso quando faz predições, fornecendo informações sobre tipos de erros cometidos pelo classificador.</p>
<p>Considerando o problema das meias-luas e os tipos de erro de classificação descritos anteriormente a matriz de confusão é dada por</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/matrizconfusao.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>Para exemplificar, considere o exemplo de classificação da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a>, em que há 10 predições, sendo <span class="math inline">\(\text{VP}=3\)</span>, <span class="math inline">\(\text{VN}=4\)</span>, <span class="math inline">\(\text{FP}=1\)</span> e <span class="math inline">\(\text{FN}=2\)</span>.</p>
<div id="tbl-clasex" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-clasex-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;2: Exemplo de classificação.
</figcaption>
<div aria-describedby="tbl-clasex-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">Rótulo Correto</td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
</tr>
<tr class="even">
<td style="text-align: left;">Rótulo Predito</td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
<td style="text-align: center;"><font color="red">N</font></td>
<td style="text-align: center;"><font color="blue">S</font></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Tipo de erro</td>
<td style="text-align: center;">FN</td>
<td style="text-align: center;">VN</td>
<td style="text-align: center;">VN</td>
<td style="text-align: center;">VP</td>
<td style="text-align: center;">VP</td>
<td style="text-align: center;">VN</td>
<td style="text-align: center;">FN</td>
<td style="text-align: center;">VP</td>
<td style="text-align: center;">VN</td>
<td style="text-align: center;">FP</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A matriz de confusão do exemplo da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a> é dada por</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/matrizconfusao2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>Para um bom classificador a matriz de confusão deve ter valores na diagonal principal muito maiores que os valores da antidiagonal, que idealmente deveriam ser iguais a zero.</p>
<p>Vale notar que, apesar desta ser a definição mais usual da matriz de confusão, essa definição pode variar em algumas referências ou em algumas bibliotecas de software, como é o caso do <em>scikit-learn</em>, que define a matriz de confusão como a transposta da matriz aqui apresentada, ou seja, com as linhas usadas para representar os valores verdadeiros e as colunas para representar os valores preditos.</p>
</section>
<section id="acurácia-e-taxa-de-erro" class="level2">
<h2 class="anchored" data-anchor-id="acurácia-e-taxa-de-erro">Acurácia e taxa de erro</h2>
<p>Uma vez determinados os erros de classificação, as seguintes métricas podem ser calculadas:</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{Acurácia}=\frac{\# \text{predições corretas}}{\# \text{predições totais}}=\frac{\text{VP}+\text{VN}}{\text{VP}+\text{VN}+\text{FP}+\text{FN}}
$}
\end{equation*}\]</span></p>
<p>e</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{Taxa de erro}=\frac{\# \text{predições incorretas}}{\# \text{predições totais}}=\frac{\text{FP}+\text{FN}}{\text{VP}+\text{VN}+\text{FP}+\text{FN}}=1-\text{Acurácia}.
$}
\end{equation*}\]</span></p>
<p>Considerando o exemplo de classificação da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a>, temos</p>
<p><span class="math display">\[
\text{Acurácia}=\frac{\text{VP}+\text{VN}}{\text{VP}+\text{VN}+\text{FP}+\text{FN}}=\frac{3+4}{10}=0,7=70\%
\]</span></p>
<p>e</p>
<p><span class="math display">\[
\text{Taxa de erro}=1-\text{Acurácia}=1-0,7=0,3=30\%.
\]</span></p>
<p>A acurácia não é uma métrica adequada para analisar a classificação quando as classes estão desbalanceadas. Suponha, por exemplo, que <span class="math inline">\(97\%\)</span> dos exemplos de treinamento sejam da Região B e apenas <span class="math inline">\(3\%\)</span> da Região A. Se o modelo consegue predizer apenas os pontos da Região B, a acurácia será de <span class="math inline">\(97\%\)</span> e nenhum ponto da Região A será detectado. Portanto, o modelo parece ter um ótimo desempenho com base na acurácia, mas falha ao detectar pontos da Região A.</p>
</section>
<section id="precisão-sensibilidade-e-f_1-score" class="level2">
<h2 class="anchored" data-anchor-id="precisão-sensibilidade-e-f_1-score">Precisão, Sensibilidade e <span class="math inline">\(F_1\)</span>-<em>score</em></h2>
<p>Voltando à <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>, considerando que os elementos relevantes são os pontos das Região A, a precisão mede a fração dos elementos relevantes entre os elementos recuperados, ou seja,</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{Precisão}=\frac{\# \text{amostras positivas preditas corretamente}}{\# \text{todas as amostras preditas como positivas}}=\frac{\text{VP}}{\text{VP}+\text{FP}}.
$}
\end{equation*}\]</span></p>
<p>A precisão é uma medida que nos diz qual é a proporção dos pontos que foram classificados como pertencentes à Região A que de fato são da Região A.</p>
<p>Em contrapartida, a sensibilidade, também conhecida como taxa de verdadeiros positivos (<em>True Positive Rate</em> - TPR) ou revocação (<em>recall</em>), calcula a fração dos elementos relevantes que foram recuperados, ou seja,</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{Sensibilidade}=\frac{\# \text{amostras positivas preditas corretamente}}{\# \text{todas as amostras com rótulos positivos}}=\frac{\text{VP}}{\text{VP}+\text{FN}}.
$}
\end{equation*}\]</span></p>
<p>A sensibilidade é uma medida que nos diz qual é a proporção dos pontos que de fato são da Região A que foram classificados como pertencentes a essa região.</p>
<p>Usando o diagrama da <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>, as métricas acima estão ilustradas na <a href="#fig-ps" class="quarto-xref">Figura&nbsp;2</a>.</p>
<div id="fig-ps" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/diagrama.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2: Ilustração do cálculo da precisão e sensibilidade seguindo o esquema da <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>. Fonte: Adaptado de <a href="https://en.wikipedia.org/wiki/Precision_and_recall">https://en.wikipedia.org/wiki/Precision_and_recall</a>
</figcaption>
</figure>
</div>
<p>A sensibilidade fornece informação sobre o desempenho do classificador com relação aos falsos negativos, enquanto a precisão fornece informação sobre seu desempenho em relação aos falsos positivos. Dessa forma, se desejamos minimizar os falsos negativos, a sensibilidade deve ser o mais próxima possível de 100% sem que a precisão seja muito ruim. Em contrapartida, se desejamos minimizar os falsos positivos, deve-se fazer a precisão tão próxima de 100% quanto possível.</p>
<p>Vale notar que existe um compromisso entre o desempenho em termos de precisão e sensibilidade. Em geral, quando busca-se aumentar a precisão, diminuindo o número de falsos positivos, diminui-se sensibilidade, pois o número de falsos negativos aumenta e vice-versa. Dependendo do problema, pode ser mais interessante priorizar uma ou outra métrica, alterando-se o limiar utilizado para classificar um exemplo positivo. Um classificador com alta precisão tende a deixar alguns exemplos de fora (falsos negativos) mas aqueles classificados como positivo tem uma alta qualidade (poucos falsos positivos). Já um classificador com uma sensibilidade alta, deixa poucos exemplos de fora (falsos negativos) mas aqueles classificados como positivo não tem tanta qualidade (mais falsos positivos).</p>
<p>Uma métrica que combina a precisão e a sensibilidade é a <span class="math inline">\(F_1\textit{-score}\)</span> definida como a média harmônica dessas métricas, isto é,</p>
<p><span class="math display">\[
F_1\textit{-score}=2\frac{\text{Precisão}\times\text{Sensibilidade}}{\text{Precisão}+\text{Sensibilidade}}.
\]</span></p>
<p>A média harmônica é uma espécie de média quando a precisão e a sensibilidade são iguais. Mas quando elas são diferentes, essa métrica fica mais próxima do menor valor em comparação com o maior. Portanto, se a precisão ou sensibilidade for muito pequena, o <span class="math inline">\(F_1\textit{-score}\)</span> levanta uma bandeira e fica mais próximo do menor valor, dando ao modelo uma pontuação apropriada em vez de apenas uma simples média aritmética.</p>
<p>No exemplo da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a>, temos</p>
<p><span class="math display">\[
\text{Precisão}=\frac{\text{VP}}{\text{VP}+\text{FP}}=\frac{3}{3+1}=0,75=75\%,
\]</span></p>
<p><span class="math display">\[
\text{Sensibilidade}=\frac{\text{VP}}{\text{VP}+\text{FN}}=\frac{3}{3+2}=0,6=60\%,
\]</span></p>
<p>e</p>
<p><span class="math display">\[
F_1\textit{-score}=2\frac{0,75\times 0,60}{0,75+0,60}=0,6667=66,67\%.
\]</span></p>
<p>Na literatura, existem outras medidas do tipo <span class="math inline">\(F\)</span> que envolvem a precisão e sensibilidade, mas a <span class="math inline">\(F_1\textit{-score}\)</span> é a mais utilizada.</p>
</section>
<section id="especificidade-e-taxa-de-falsos-positivos" class="level2">
<h2 class="anchored" data-anchor-id="especificidade-e-taxa-de-falsos-positivos">Especificidade e taxa de falsos positivos</h2>
<p>A especificidade, em contraste à sensibilidade, é uma medida que fornece a proporção de pontos que não pertencem à Região A e que foram previstos pelo modelo como não pertencentes à essa região. Considera-se então a razão entre o número de pontos classificados corretamente como não pertencentes à Região A, ou seja, os pontos que são VN, e o número de pontos que de fato não pertencem à Região~A, ou seja, os pontos que são FP e VN. Dessa forma, define-se essa métrica como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{Especificidade}=\frac{\# \text{amostras negativas preditas corretamente}}{\# \text{todas as amostras preditas com rótulos negativos}}=\frac{\text{VN}}{\text{VN}+\text{FP}}.
$}
\end{equation*}\]</span></p>
<p>Usando o diagrama da <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>, a especificidade está ilustrada na <a href="#fig-ps2" class="quarto-xref">Figura&nbsp;3</a>.</p>
<div id="fig-ps2" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ps2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/PS2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:32.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ps2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3: Ilustração do cálculo da especificidade seguindo o esquema da <a href="#fig-diagrama" class="quarto-xref">Figura&nbsp;1</a>. Fonte: Adaptado de <a href="https://en.wikipedia.org/wiki/Precision_and_recall">https://en.wikipedia.org/wiki/Precision_and_recall</a>
</figcaption>
</figure>
</div>
<p>Também é comum definir a taxa de falsos positivos (<em>False Positive Rate</em> - FPR), ou seja,</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{FPR}=\frac{\text{FP}}{\text{VN}+\text{FP}}=1-\text{Especificidade}.
$}
\end{equation*}\]</span></p>
<p>Essa taxa fornece a proporção da classe negativa (pontos da Região B no nosso exemplo), que foi classificada incorretamente. Uma FPR baixa é desejável uma vez que se deseja classificar corretamente os elementos da classe negativa.</p>
<p>No exemplo da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a>, temos</p>
<p><span class="math display">\[
\text{Especificidade}=\frac{\text{VN}}{\text{VN}+\text{FP}}=\frac{4}{4+1}=0,8=80\%.
\]</span></p>
</section>
<section id="coeficiente-de-correlação-de-matthew" class="level2">
<h2 class="anchored" data-anchor-id="coeficiente-de-correlação-de-matthew">Coeficiente de correlação de Matthew</h2>
<p>Para classificação binária, uma métrica pouco utilizada na prática, mas muito interessante é o coeficiente de correlação de Matthew (<em>Matthews Correlation Coefficient</em> - MCC). Para obter essa métrica, trate a classe verdadeira e a classe prevista como duas variáveis aleatórias binárias e calcule seu coeficiente de correlação. Quanto maior a correlação entre os valores verdadeiros e preditos, melhor a predição. Esse coeficiente de correlação é chamado de MCC quando aplicado a classificadores e é definido como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
\text{MCC}=\frac{\text{VP}\times\text{VN}-\text{FP}\times\text{FN}}{\sqrt{(\text{VP}+\text{FP})(\text{VP}+\text{FN})(\text{VN}+\text{FP})(\text{VN}+\text{FN})}}.
$}
\end{equation*}\]</span></p>
<p>Algumas propriedades interessantes dessa métrica podem ser derivadas de sua definição: quando o classificador é perfeito (<span class="math inline">\(\text{FP} = \text{FN} = 0\)</span>) o valor de MCC é <span class="math inline">\(1\)</span>, indicando correlação positiva perfeita. Em contrapartida, quando o classificador sempre classifica mal (<span class="math inline">\(\text{VP} = \text{VN} = 0\)</span>), obtemos um valor de <span class="math inline">\(-1\)</span>, representando uma correlação negativa perfeita (neste caso, você pode simplesmente reverter o resultado do classificador para obter o classificador ideal). O valor do MCC está sempre entre <span class="math inline">\(-1\)</span> e <span class="math inline">\(1\)</span>, com <span class="math inline">\(0\)</span> significando que o classificador não é melhor do que um lançamento aleatório de uma moeda honesta. O MCC também é perfeitamente simétrico, portanto, nenhuma classe é mais importante que a outra. Por fim, o MCC leva em conta os quatro valores da matriz de confusão, e um valor alto (próximo de 1) significa que ambas as classes são bem preditas, mesmo que uma classe esteja sub (ou super) representada.</p>
<p>No exemplo da <a href="#tbl-clasex" class="quarto-xref">Tabela&nbsp;2</a>, temos</p>
<p><span class="math display">\[
\text{MCC}=
\frac{3\times4-1\times2}{\sqrt{(3+1)(3+2)(4+1)(4+2)}}=\frac{10}{\sqrt{600}}=0,408.
\]</span></p>
</section>
<section id="área-sob-a-curva-roc" class="level2">
<h2 class="anchored" data-anchor-id="área-sob-a-curva-roc">Área sob a curva ROC</h2>
<p>No problema das meias-luas, adotamos o limiar igual a 0. Ou seja, quando a saída do classificador é maior ou igual a zero, o ponto é classificado como pertencente à Região A e quando é menor que zero como pertencente à Região B. Esse limiar é razoável neste caso, uma vez que adotamos <span class="math inline">\(d\in \{-1, +1\}\)</span> como sinal desejado. No entanto, suponha que a saída de um determinado classificador treinado para este problema siga duas distribuições gaussianas com variância unitária, mas com médias diferentes: uma igual <span class="math inline">\(-4\)</span> e outra igual a <span class="math inline">\(1,5\)</span>, como mostrado na <a href="#fig-limiar" class="quarto-xref">Figura&nbsp;4</a>. A gaussiana com média negativa corresponde aos pontos que devem ser classificados como pertencentes à Região B. Enquanto a gaussiana com média positiva corresponde aos pontos que devem ser classificados como pertencentes à Região A. Neste caso, para minimizar o erro de classificação, o limiar deve ser igual a <span class="math inline">\(-1,25\)</span> e não <span class="math inline">\(0\)</span>. O valor do limiar influencia nas medidas de desempenho do classificador. Neste exemplo, qualquer outro limiar diferente de <span class="math inline">\(-1,25\)</span> levará a um maior erro de classificação. Na escolha do limiar, devem ser feitos testes para cada valor, ou seja, pode-se gerar a matriz de confusão e comparar as métricas discutidas até agora. No entanto, o melhor a se fazer é considerar a área sob a curva ROC como veremos a seguir.</p>
<div id="fig-limiar" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-limiar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/limiar.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-limiar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;4: Exemplo de função densidade de probabilidade da saída do classificador. A curva vermelha mostra a distribuição da saída ser negativa e a da direita da saída ser positiva.
</figcaption>
</figure>
</div>
<p>Dado um limiar, a curva ROC (<em>Receiver Operator Characteristic</em>) é um gráfico da taxa de verdadeiros positivos (sensibilidade) em função da taxa de falsos positivos (<span class="math inline">\(\text{FPR}=1-\text{Especificidade}\)</span>). A área sob essa curva (<em>area under the curve</em> - AUC) é uma medida da habilidade do classificador de distinguir entre as classes e é usada frequentemente como métrica. Quanto maior a AUC, melhor o desempenho do classificador. Na <a href="#fig-rocabc" class="quarto-xref">Figura&nbsp;5</a>, são mostrados exemplos de curvas ROC com três valores distintos de AUC: <span class="math inline">\(1\)</span>, <span class="math inline">\(0,\!5\)</span> e <span class="math inline">\(0,\!8\)</span>. As áreas sob as curvas ROC estão pintadas de amarelo. Quando <span class="math inline">\(\text{AUC}=1\)</span> (<a href="#fig-rocabc" class="quarto-xref">Figura&nbsp;5</a> (a)), o classificador é capaz de distinguir perfeitamente os pontos da Região A dos pontos da Região B. Se <span class="math inline">\(\text{AUC}=0\)</span>, o modelo classifica todos os pontos da Região A como pertencentes a Região B e vice-versa. Quando <span class="math inline">\(\text{AUC}=0,5\)</span> (<a href="#fig-rocabc" class="quarto-xref">Figura&nbsp;5</a> (b)), o classificador não é capaz de distinguir entre as classes: é como se uma moeda fosse lançada para gerar a classificação. Por fim, para <span class="math inline">\(0,\!5 &lt; \text{AUC}&lt; 1\)</span> (<a href="#fig-rocabc" class="quarto-xref">Figura&nbsp;5</a> (c)), há uma grande chance de que o classificador seja capaz de distinguir as classes. Isso ocorre porque o classificador detecta mais verdadeiros positivos e verdadeiros negativos do que falsos negativos e falsos positivos.</p>
<div id="fig-rocabc" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rocabc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/ROCabc.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rocabc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;5: Exemplos de curvas ROC com três valores distintos de AUC: (a) <span class="math inline">\(\text{AUC}=1\)</span>, (b) <span class="math inline">\(\text{AUC}=0,\!5\)</span> e (c) <span class="math inline">\(\text{AUC}=0,\!8\)</span>.
</figcaption>
</figure>
</div>
<p>Em uma curva ROC, um valor mais alto do eixo <span class="math inline">\(x\)</span> indica um maior número de falsos positivos do que de verdadeiros negativos. Enquanto um valor mais alto do eixo <span class="math inline">\(y\)</span> indica um maior número de verdadeiros positivos do que falsos negativos. Assim, a escolha do limiar deve levar em conta um compromisso entre o número de falsos positivos e falsos negativos.</p>
</section>
<section id="problemas-de-classificação-multiclasse" class="level2">
<h2 class="anchored" data-anchor-id="problemas-de-classificação-multiclasse">Problemas de classificação multiclasse</h2>
<p>Até agora, quando abordamos as métricas de desempenho, focamos em problemas de classificação binária. No entanto, essas métricas podem ser estendidas para problemas de classificação multiclasse. Um bom tutorial sobre o assunto pode ser encontrado em <span class="citation" data-cites="Grandini2020">(<a href="#ref-Grandini2020" role="doc-biblioref">Grandini, Bagli, e Visani 2020</a>)</span>.</p>
</section>
<section id="problemas-de-regressão" class="level2">
<h2 class="anchored" data-anchor-id="problemas-de-regressão">Problemas de regressão</h2>
<p>As medidas de desempenho vistas até o momento não servem para problemas de regressão. A seguir vamos abordar três medidas que podem ser usadas para avaliar modelos de regressão.</p>
<section id="erro-absoluto-médio" class="level3">
<h3 class="anchored" data-anchor-id="erro-absoluto-médio">Erro absoluto médio</h3>
<p>O erro absoluto médio (<em>mean absolute error</em> - MAE) é a média do módulo da diferença entre os valores desejados e os valores preditos. Ele fornece uma medida de quão longe as predições estão dos valores verdadeiro, mas não fornece nenhuma ideia da direção do erro, ou seja, se o modelo está subestimando ou superestimando os dados. O erro absoluto médio é calculado como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
{\rm MAE}=\frac{1}{N_\text{teste}}\sum_{n=1}^{N_{\text{teste}}}|d_n-y_n|.
$}
\end{equation*}\]</span></p>
</section>
<section id="erro-quadrático-médio" class="level3">
<h3 class="anchored" data-anchor-id="erro-quadrático-médio">Erro quadrático médio</h3>
<p>O erro quadrático médio (<em>mean square error</em> - MSE) é semelhante ao erro absoluto médio. A única diferença é que o MSE toma a média do quadrado da diferença entre os valores desejados e os valores preditos. Como se calcula o quadrado do erro, o efeito de erros maiores se torna mais pronunciado do que o de erros menores. O MSE é calculado como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
{\rm MSE}=\frac{1}{N_\text{teste}}\sum_{n=1}^{N_{\text{teste}}}(d_n-y_n)^2.
$}
\end{equation*}\]</span></p>
<p>É comum usar também a raiz quadrada do MSE (<em>root mean square error</em> - RMSE) como métrica, ou seja, <span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
{\rm RMSE}=\sqrt{{\rm MSE}}=\sqrt{\frac{1}{N_\text{teste}}\sum_{n=1}^{N_{\text{teste}}}(d_n-y_n)^2}.
$}
\end{equation*}\]</span></p>
<p>A vantagem é que tanto essa métrica como o MAE possuem a mesma unidade da variável predita, o que torna sua interpretação mais simples.</p>
</section>
<section id="r2" class="level3">
<h3 class="anchored" data-anchor-id="r2"><span class="math inline">\(R^2\)</span></h3>
<p>A métrica <span class="math inline">\(R^2\)</span> é usada para fins explicativos e fornece uma indicação da qualidade ou ajuste de um conjunto de valores de saída previstos aos valores desejados. Essa métrica é calculada como</p>
<p><span class="math display">\[\begin{equation*}
\fbox{$\displaystyle
R^2=1-\displaystyle\frac{\displaystyle\sum_{n=1}^{N_{\text{teste}}}(d_n-y_n)^2}{\displaystyle\sum_{n=1}^{N_{\text{teste}}}(\overline{d}-d_n)^2},
$}
\end{equation*}\]</span></p>
<p>em que</p>
<p><span class="math display">\[
\overline{d}=\frac{1}{N_{\text{teste}}}\sum_{n=1}^{N_{\text{teste}}}d_n
\]</span></p>
<p>é a média dos valores desejados do conjunto de teste. Note que o denominador da fração que aparece na definição de <span class="math inline">\(R^2\)</span> é proporcional à variância dos dados de teste. No melhor caso, os valores preditos são exatamente iguais aos valores desejados, o que leva a <span class="math inline">\(R^2=1\)</span>. Caso o modelo leve a <span class="math inline">\(y_n=\overline{d}\)</span>, <span class="math inline">\(n=1, 2, \cdots, N_{\text{teste}}\)</span>, que é conhecido como modelo base, teremos <span class="math inline">\(R^2=0\)</span>. Modelos cujas predições são piores que as do modelo base podem levar a <span class="math inline">\(R^2\)</span> negativo.</p>
</section>
</section>
</div>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Referências</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Grandini2020" class="csl-entry" role="listitem">
Grandini, Margherita, Enrico Bagli, e Giorgio Visani. 2020. <em>Metrics for Multi-Class Classification: an Overview</em>. <a href="https://arxiv.org/abs/2008.05756" class="uri">https://arxiv.org/abs/2008.05756</a>.
</div>
</div></section></div></main> <!-- /main -->
<script>
var custom_title = document.querySelectorAll('.custom .theorem-title');

for (let i = 0; i < custom_title.length; i++ ) {
   var mod_name = custom_title[i].innerHTML;
   custom_title[i].innerHTML = mod_name.replace("Exemplo", "Algoritmo");
};
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiada");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiada");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>